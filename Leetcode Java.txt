Topics: Maths
---------------
7. Reverse Integer
https://leetcode.com/problems/reverse-integer/
V7.1
class Solution {
    public int reverse(int x) {
        int minInt = -2147483648;
        int maxInt = 2147483647;
        int reversedNumber = 0;
        boolean isNegative = false;
        if (x < 0) {
            isNegative = true;
            x = -1 * x;
        }
        String org = String.valueOf(x);
        int indexLen = org.length() - 1;
        char[] revChars = new char[indexLen + 1];
        int i = 0;
        while (indexLen >= 0) {
            revChars[i++] = org.charAt(indexLen--);
        }
        //System.out.println(revChars);
        return this.getReversedNumber(revChars, isNegative);
    }

    public int charArrayToInteger(char[] array) {
        String arr = new String(array);
        int number = Integer.parseInt(arr);

        return number;
    }

    private int getReversedNumber(char[] revChars, boolean negative) {
        char[] maxNum = {'2', '1', '4', '7', '4', '8', '3', '6', '4', '7'};
        int numFlag = 1;
        if (negative) {
            maxNum[9] = '8';
            //System.out.println("Neg");
            numFlag = -1;
        }
        
        // length checking
        if (revChars.length > maxNum.length) {
            return 0;
        } else if (revChars.length < maxNum.length) {
            return  numFlag * this.charArrayToInteger(revChars);
        } else {
            //2147483647
            //2137483647
            int indexlen = maxNum.length;
            for (int i = 0; i < indexlen; i++) {
                if (maxNum[i] == revChars[i]) {
                    
                } else if (maxNum[i] > revChars[i]) {
                    return numFlag * this.charArrayToInteger(revChars);
                } else {
                    return 0;
                }
            }
        }
        return numFlag * this.charArrayToInteger(revChars);
    }
}

Topics: Tree
---------------------
226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
V226.1
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        TreeNode tempNode = root.left;
        root.left = root.right;
        root.right = tempNode;
        root.left = this.invertTree(root.left);
        root.right = this.invertTree(root.right);
        return root;
    }
}

Topics: DFS
---------------------
100. same Tree
https://leetcode.com/problems/same-tree/
V100.1
START:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        String pPath = this.traversePath(p);
        String qPath = this.traversePath(q);
        if (pPath.equals(qPath)) {
            return true;
        }
        return false;
    }
    
    private String traversePath(TreeNode node) {
        if (node == null) {
            return "N";
        }
        String leftNodesPath = this.traversePath(node.left);
        int currentPath = node.val;
        String rightNodesPath = this.traversePath(node.right);
        return leftNodesPath  + rightNodesPath + currentPath;
    }
}
:END

Topics: Greedy
---------------------
455. Assign Cookies
https://leetcode.com/problems/assign-cookies/
V455.1
START:
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int currentCookieIndex = 0;
        int gLen = g.length;
        int sLen = s.length;
        int contentChildNumber = 0;
        for (int i = 0; i < gLen && currentCookieIndex < sLen; i++) {
            if (g[i] <= s[currentCookieIndex]) {
                currentCookieIndex++;
                contentChildNumber++;
            } else {
                currentCookieIndex++;
                i--;
            }
        }
        return contentChildNumber;
    }
}
:END


Topics: HashTable
---------------------
205. Isomorphic Strings
https://leetcode.com/problems/isomorphic-strings/
V205.1
START:
class Solution {
    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> sMap = new HashMap<>();
        Map<Character, Character> tMap = new HashMap<>();
        int len = s.length();
        for (int i = 0; i < len; i++) {
            char sCh = s.charAt(i);
            char tCh = t.charAt(i);

            if (sMap.containsKey(sCh)) {
                if (tCh != sMap.get(sCh)) {
                    return false;
                }
            } else if (tMap.containsKey(tCh)) {
                return false;
            } else {
                sMap.put(sCh,tCh);
                tMap.put(tCh,sCh);
            }
        }
        return true;
    }
}
:END


Topics: Binary Search
---------------------
278. First Bad Version
https://leetcode.com/problems/first-bad-version/
V278.1 Time Limit excede
START:
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        // 1 2 3 -4 5
        int lastGoodVersion = 0;
        int lastBadVersion = n;

        while (lastBadVersion - lastGoodVersion != 1) {
            n = (lastBadVersion + lastGoodVersion) / 2;
            boolean isBad = isBadVersion(n);
            if (isBad) {
                lastBadVersion = n;
            } else {
                lastGoodVersion = n;
            }
        }
        return lastBadVersion;
    }
}
:END

V278.2 Accepted
START:
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
   public int firstBadVersion(int n) {
        // 1 2 3 -4 5
        int lastGoodVersion = 0; // could not be any good version
        int lastBadVersion = n;

        while (lastBadVersion - lastGoodVersion != 1) {
            //n = (lastBadVersion + lastGoodVersion) / 2;
            n = lastGoodVersion + (lastBadVersion - lastGoodVersion) / 2;
            boolean isBad = isBadVersion(n);
            if (isBad) {
                lastBadVersion = n;
            } else {
                lastGoodVersion = n;
            }
        }
        return lastBadVersion;
    }
}
:END

Topics: Breadth-First-Search
----------------------------
993. Cousins in Binary Tree
https://leetcode.com/problems/cousins-in-binary-tree/
V993.1
START:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        boolean executeLoop = true;
		boolean isCousins = false;
        while (executeLoop) {
            int currentLevelNodesNumber = q.size();
            if (currentLevelNodesNumber == 0) {
                break;
            }

            for (int i = 0; i < currentLevelNodesNumber; i++) {
                TreeNode curNode = q.remove();
                int[] tArr = new int[2];
                TreeNode leftNode = curNode.left;
                if (leftNode != null) {
                    q.add(leftNode);
                    tArr[0] = leftNode.val;
                }
                TreeNode rightNode = curNode.right;
                if (rightNode != null) {
                    q.add(rightNode);
                    tArr[1] = rightNode.val;
                }
                if (!executeLoop && this.isValueExists(tArr, x, y)) {
                    return true;
                } else if (this.isValueExists(tArr, x, y)) {
                    executeLoop = false; // perform search only in this level
                }
            }
        }
        return isCousins;
    }


    public boolean isValueExists(int[] arr, int x, int y) {
        for (int element : arr) {
            if (element == x || element == y) {
               return true;
            }
        }
        return false;
    }
}
V993.2 try recursively
V993.3 try using dfs
:END

Topics: Sort
----------------------------
1528. Shuffle String
https://leetcode.com/problems/shuffle-string/
V1528.1
START:
class Solution {
    public String restoreString(String s, int[] indices) {
        int len = indices.length;
        char[] newArr = new char[len];
        for (int i = 0; i < len; i++) {
            newArr[indices[i]] = s.charAt(i);
        }
        return String.valueOf(newArr);
    }
}
:END

Topics: Two Pointers
----------------------------
1800. Maximum Ascending Subarray Sum
https://leetcode.com/problems/maximum-ascending-subarray-sum/
V1800.1
START:
class Solution {
    public int maxAscendingSum(int[] nums) {
        int maxSum = 0;
        int tempSum = nums[0];
        int numlen = nums.length;

		for (int i = 1; i < numlen; i++) {
            if (nums[i] > nums[i-1]) {
                tempSum += nums[i];
            } else {
                if (tempSum > maxSum) {
                    maxSum = tempSum;
                }
                tempSum = nums[i];
            }
        }
        if (tempSum > maxSum) {
            maxSum = tempSum;
        }
        return maxSum;
    }
}
:END
