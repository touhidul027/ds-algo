Category: Maths
---------------
7. Reverse Integer
https://leetcode.com/problems/reverse-integer/
V7.1
class Solution {
    public int reverse(int x) {
        int minInt = -2147483648;
        int maxInt = 2147483647;
        int reversedNumber = 0;
        boolean isNegative = false;
        if (x < 0) {
            isNegative = true;
            x = -1 * x;
        }
        String org = String.valueOf(x);
        int indexLen = org.length() - 1;
        char[] revChars = new char[indexLen + 1];
        int i = 0;
        while (indexLen >= 0) {
            revChars[i++] = org.charAt(indexLen--);
        }
        //System.out.println(revChars);
        return this.getReversedNumber(revChars, isNegative);
    }

    public int charArrayToInteger(char[] array) {
        String arr = new String(array);
        int number = Integer.parseInt(arr);

        return number;
    }

    private int getReversedNumber(char[] revChars, boolean negative) {
        char[] maxNum = {'2', '1', '4', '7', '4', '8', '3', '6', '4', '7'};
        int numFlag = 1;
        if (negative) {
            maxNum[9] = '8';
            //System.out.println("Neg");
            numFlag = -1;
        }
        
        // length checking
        if (revChars.length > maxNum.length) {
            return 0;
        } else if (revChars.length < maxNum.length) {
            return  numFlag * this.charArrayToInteger(revChars);
        } else {
            //2147483647
            //2137483647
            int indexlen = maxNum.length;
            for (int i = 0; i < indexlen; i++) {
                if (maxNum[i] == revChars[i]) {
                    
                } else if (maxNum[i] > revChars[i]) {
                    return numFlag * this.charArrayToInteger(revChars);
                } else {
                    return 0;
                }
            }
        }
        return numFlag * this.charArrayToInteger(revChars);
    }
}

Category: Tree
---------------------
226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
V226.1
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        TreeNode tempNode = root.left;
        root.left = root.right;
        root.right = tempNode;
        root.left = this.invertTree(root.left);
        root.right = this.invertTree(root.right);
        return root;
    }
}

Category: DFS
---------------------
100. same Tree
https://leetcode.com/problems/same-tree/
V100.1
START:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        String pPath = this.traversePath(p);
        String qPath = this.traversePath(q);
        if (pPath.equals(qPath)) {
            return true;
        }
        return false;
    }
    
    private String traversePath(TreeNode node) {
        if (node == null) {
            return "N";
        }
        String leftNodesPath = this.traversePath(node.left);
        int currentPath = node.val;
        String rightNodesPath = this.traversePath(node.right);
        return leftNodesPath  + rightNodesPath + currentPath;
    }
}
:END