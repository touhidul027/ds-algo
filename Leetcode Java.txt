Topics: Maths
---------------
7. Reverse Integer
https://leetcode.com/problems/reverse-integer/
V7.1
class Solution {
    public int reverse(int x) {
        int minInt = -2147483648;
        int maxInt = 2147483647;
        int reversedNumber = 0;
        boolean isNegative = false;
        if (x < 0) {
            isNegative = true;
            x = -1 * x;
        }
        String org = String.valueOf(x);
        int indexLen = org.length() - 1;
        char[] revChars = new char[indexLen + 1];
        int i = 0;
        while (indexLen >= 0) {
            revChars[i++] = org.charAt(indexLen--);
        }
        //System.out.println(revChars);
        return this.getReversedNumber(revChars, isNegative);
    }

    public int charArrayToInteger(char[] array) {
        String arr = new String(array);
        int number = Integer.parseInt(arr);

        return number;
    }

    private int getReversedNumber(char[] revChars, boolean negative) {
        char[] maxNum = {'2', '1', '4', '7', '4', '8', '3', '6', '4', '7'};
        int numFlag = 1;
        if (negative) {
            maxNum[9] = '8';
            //System.out.println("Neg");
            numFlag = -1;
        }
        
        // length checking
        if (revChars.length > maxNum.length) {
            return 0;
        } else if (revChars.length < maxNum.length) {
            return  numFlag * this.charArrayToInteger(revChars);
        } else {
            //2147483647
            //2137483647
            int indexlen = maxNum.length;
            for (int i = 0; i < indexlen; i++) {
                if (maxNum[i] == revChars[i]) {
                    
                } else if (maxNum[i] > revChars[i]) {
                    return numFlag * this.charArrayToInteger(revChars);
                } else {
                    return 0;
                }
            }
        }
        return numFlag * this.charArrayToInteger(revChars);
    }
}

Topics: Tree
---------------------
226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
V226.1
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        TreeNode tempNode = root.left;
        root.left = root.right;
        root.right = tempNode;
        root.left = this.invertTree(root.left);
        root.right = this.invertTree(root.right);
        return root;
    }
}

Topics: DFS
---------------------
100. same Tree
https://leetcode.com/problems/same-tree/
V100.1
START:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        String pPath = this.traversePath(p);
        String qPath = this.traversePath(q);
        if (pPath.equals(qPath)) {
            return true;
        }
        return false;
    }
    
    private String traversePath(TreeNode node) {
        if (node == null) {
            return "N";
        }
        String leftNodesPath = this.traversePath(node.left);
        int currentPath = node.val;
        String rightNodesPath = this.traversePath(node.right);
        return leftNodesPath  + rightNodesPath + currentPath;
    }
}
:END

Topics: Greedy
---------------------
455. Assign Cookies
https://leetcode.com/problems/assign-cookies/
V455.1
START:
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int currentCookieIndex = 0;
        int gLen = g.length;
        int sLen = s.length;
        int contentChildNumber = 0;
        for (int i = 0; i < gLen && currentCookieIndex < sLen; i++) {
            if (g[i] <= s[currentCookieIndex]) {
                currentCookieIndex++;
                contentChildNumber++;
            } else {
                currentCookieIndex++;
                i--;
            }
        }
        return contentChildNumber;
    }
}
:END


Topics: HashTable
---------------------
205. Isomorphic Strings
https://leetcode.com/problems/isomorphic-strings/
V205.1
START:
class Solution {
    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> sMap = new HashMap<>();
        Map<Character, Character> tMap = new HashMap<>();
        int len = s.length();
        for (int i = 0; i < len; i++) {
            char sCh = s.charAt(i);
            char tCh = t.charAt(i);

            if (sMap.containsKey(sCh)) {
                if (tCh != sMap.get(sCh)) {
                    return false;
                }
            } else if (tMap.containsKey(tCh)) {
                return false;
            } else {
                sMap.put(sCh,tCh);
                tMap.put(tCh,sCh);
            }
        }
        return true;
    }
}
:END


Topics: Binary Search
---------------------
278. First Bad Version
https://leetcode.com/problems/first-bad-version/
V278.1 Time Limit excede
START:
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        // 1 2 3 -4 5
        int lastGoodVersion = 0;
        int lastBadVersion = n;

        while (lastBadVersion - lastGoodVersion != 1) {
            n = (lastBadVersion + lastGoodVersion) / 2;
            boolean isBad = isBadVersion(n);
            if (isBad) {
                lastBadVersion = n;
            } else {
                lastGoodVersion = n;
            }
        }
        return lastBadVersion;
    }
}
:END

V278.2 Accepted
START:
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
   public int firstBadVersion(int n) {
        // 1 2 3 -4 5
        int lastGoodVersion = 0; // could not be any good version
        int lastBadVersion = n;

        while (lastBadVersion - lastGoodVersion != 1) {
            //n = (lastBadVersion + lastGoodVersion) / 2;
            n = lastGoodVersion + (lastBadVersion - lastGoodVersion) / 2;
            boolean isBad = isBadVersion(n);
            if (isBad) {
                lastBadVersion = n;
            } else {
                lastGoodVersion = n;
            }
        }
        return lastBadVersion;
    }
}
:END

Topics: Breadth-First-Search
----------------------------
993. Cousins in Binary Tree
https://leetcode.com/problems/cousins-in-binary-tree/
V993.1
START:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        boolean executeLoop = true;
		boolean isCousins = false;
        while (executeLoop) {
            int currentLevelNodesNumber = q.size();
            if (currentLevelNodesNumber == 0) {
                break;
            }

            for (int i = 0; i < currentLevelNodesNumber; i++) {
                TreeNode curNode = q.remove();
                int[] tArr = new int[2];
                TreeNode leftNode = curNode.left;
                if (leftNode != null) {
                    q.add(leftNode);
                    tArr[0] = leftNode.val;
                }
                TreeNode rightNode = curNode.right;
                if (rightNode != null) {
                    q.add(rightNode);
                    tArr[1] = rightNode.val;
                }
                if (!executeLoop && this.isValueExists(tArr, x, y)) {
                    return true;
                } else if (this.isValueExists(tArr, x, y)) {
                    executeLoop = false; // perform search only in this level
                }
            }
        }
        return isCousins;
    }


    public boolean isValueExists(int[] arr, int x, int y) {
        for (int element : arr) {
            if (element == x || element == y) {
               return true;
            }
        }
        return false;
    }
}
V993.2 try recursively
V993.3 try using dfs
:END

Topics: Sort
----------------------------
1528. Shuffle String
https://leetcode.com/problems/shuffle-string/
V1528.1
START:
class Solution {
    public String restoreString(String s, int[] indices) {
        int len = indices.length;
        char[] newArr = new char[len];
        for (int i = 0; i < len; i++) {
            newArr[indices[i]] = s.charAt(i);
        }
        return String.valueOf(newArr);
    }
}
:END

Topics: Two Pointers
----------------------------
1800. Maximum Ascending Subarray Sum
https://leetcode.com/problems/maximum-ascending-subarray-sum/
V1800.1
START:
class Solution {
    public int maxAscendingSum(int[] nums) {
        int maxSum = 0;
        int tempSum = nums[0];
        int numlen = nums.length;

		for (int i = 1; i < numlen; i++) {
            if (nums[i] > nums[i-1]) {
                tempSum += nums[i];
            } else {
                if (tempSum > maxSum) {
                    maxSum = tempSum;
                }
                tempSum = nums[i];
            }
        }
        if (tempSum > maxSum) {
            maxSum = tempSum;
        }
        return maxSum;
    }
}
:END

Topics: Backtracking
----------------------------
1688. Count of Matches in Tournament
https://leetcode.com/problems/count-of-matches-in-tournament/
V1688.1
START:
class Solution {
    public int numberOfMatches(int n) {
        if (n == 1) {
            return 0;
        } else if (n == 2) {
            return 1;
        }
        return 1 + numberOfMatches(n-1);
    }
}
:END

Topics: Stack
----------------------------
1021. Remove Outermost Parentheses
https://leetcode.com/problems/remove-outermost-parentheses/
V1021.1
START:
class Solution {
    public String removeOuterParentheses(String S) {
        String sNew = "";
        Stack<Character> stack = new Stack<>();
        stack.push(S.charAt(0));
        int sLen = S.length();
        char startCh = '(';
        char endCh = ')';
        for (int i = 1; i < sLen; i++) {
            char ch = S.charAt(i);
            if (ch == startCh) {
                if (!stack.empty()) {
                    sNew += startCh;
                }
                stack.push(ch);
            } else {
                stack.pop();
                if (!stack.empty()) {
                    sNew += endCh;
                }
            }
        }
        return sNew;
    }
}
:END


Topics: Design
----------------------------
1603. Design Parking System
https://leetcode.com/problems/design-parking-system/
1603.1
START:
class ParkingSystem {
    private int big;
    private int medium;
    private int small;

    public ParkingSystem(int big, int medium, int small) {
        this.big = big;
        this.medium = medium;
        this.small = small;
    }

    public boolean addCar(int carType) {
        boolean isSlotsAvailable = false;

        switch(carType) {
            case 1:
                if (this.big > 0) {
                    this.big--;
                    isSlotsAvailable = true;
                }
                break;
            case 2:
                if (this.medium > 0) {
                    this.medium--;
                    isSlotsAvailable = true;
                }
                break;
            default:
                if (this.small > 0) {
                    this.small--;
                    isSlotsAvailable = true;
                }
        }
        return isSlotsAvailable;
    }
}

/**
 * Your ParkingSystem object will be instantiated and called as such:
 * ParkingSystem obj = new ParkingSystem(big, medium, small);
 * boolean param_1 = obj.addCar(carType);
 */
:END
1603.2 try using array



Topics: Bit Manipulation
Brush Up: https://www.baeldung.com/java-bitwise-operators
----------------------------
1342. Number of Steps to Reduce a Number to Zero
https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/
v-1342.1
START:
class Solution {
    public int numberOfSteps(int num) {
        int nSteps = 0;
        while (num != 0) {
            if ((num & 1) != 0) {
                // substract for even
                num--;
            } else {
                num = num >> 1;
            }
            nSteps++;
        }
        return nSteps;
    }
}
:END

Topics: Graph
----------------------------
997. Find the Town Judge
https://leetcode.com/problems/find-the-town-judge/
v-997.1
START:
class Solution {
    public int[][] prepareAdjacencyMatrix(int N, int[][] trust) {
        /*  Example 5:
            0	0	0	0	0	

            0	-1	0	1	1	

            0	0	-1	1	1	

            0	0	0	0	0	

            0	0	0	1	-1	
        */
        int[][] adjMarix = new int[N+1][N+1];
        int rows = trust.length;
        
        
        for (int i = 0; i < rows; i++) {
            adjMarix[trust[i][0]][trust[i][0]] = -1;
            for (int j = 1; j < trust[i].length; j++) {
                adjMarix[trust[i][0]][trust[i][j]] = 1;
            }
        }
        return adjMarix;
    }

    public int findJudge(int N, int[][] trust) {
        int[][] adjMatrix = this.prepareAdjacencyMatrix(N,trust);
        int judge = -1;
        
        // find who is not trusting anyone
        for (int i = 1; i < N + 1; i++) {
            if (adjMatrix[i][i] == 0) {
                judge = i;
                break;
            }
        }

        if (judge != -1) {
            // everyone must trust judge, else no judge
            for (int i = 1; i < N + 1; i++) {
                if (i != judge && adjMatrix[i][judge]==0) {
                    return -1;
                }
            }
        }

        return judge;
    }
}
:END
v-997.2 Review


Topics: Heap
----------------------------
1046. Last Stone Weight
https://leetcode.com/problems/last-stone-weight/
v-1046.1
START:
class Solution {
    private static int currentItems = 0;

    public static int[] heapArray(int[] stones) {
        int[] heapArray = new int[stones.length];

        // sorting array
        for (int i = 0; i < stones.length; i++) {
            heapArray = insertAsHeapArray(heapArray,stones[i]);
            System.out.println(Arrays.toString(heapArray));
        }
       // System.out.println(Arrays.toString(heapArray));
        return heapArray;
    }

    public static int[] insertAsHeapArray(int[] arr, int element) {
        // finding right place to insert element
        int index = currentItems;

        for (int i = 0; i < currentItems; i++) {
            if (arr[i] > element) {
                index = i;
                break;
            }
        }

        // trickle up the rest of array elements
        currentItems++;
        for (int i = currentItems -1; i > index ; i--) {
            arr[i] = arr[i-1];
        }

        // insert element in right place
        arr[index] = element;

        return arr;
    }

    public static int remove(int[] arr) {
        if (currentItems == 0) {
            return 0;
        }
        return arr[--currentItems];
    }

    public static boolean isLast() {
        return currentItems == 1;
    }

    public int lastStoneWeight(int[] stones) {
        int[] heapArray = heapArray(stones);
        while (currentItems > 1) {
            int larger = remove(heapArray);
            int smaller = remove(heapArray);
            if (larger - smaller > 0) {
                insertAsHeapArray(heapArray, larger-smaller);
            }
        }
        return remove(heapArray);
    }
}
:END
v-1046.2 use built in PriorityQ library class

Topics: Linked List
----------------------------
876. Middle of the Linked List
https://leetcode.com/problems/middle-of-the-linked-list/
v-876.1
START:
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode mid = head;
        ListNode jumper = head;

        while (jumper != null && jumper.next != null) {
            jumper = jumper.next.next;
            mid = mid.next;
        }
        return mid;
    }
}
:END

Topics: Recursion
----------------------------
1137. N-th Tribonacci Number
https://leetcode.com/problems/n-th-tribonacci-number/
v-1137.1
START:
class Solution {
    private Map<Integer,Integer> map = new HashMap<>();
    public int tribonacci(int n) {
        if (n < 3) {
            if (n == 0) {
                return 0;
            } else if(n == 1 || n == 2) {
                return 1;
            }
        }

        if (!map.containsKey(n)) {
            map.put(n, this.tribonacci(n - 1) +  this.tribonacci(n - 2) + this.tribonacci(n - 3));
        }

        return map.get(n);
    }
}
:END
v-1137.2 Try without recursion

Topics: Union Find
----------------------------
1584. Min Cost to Connect All Points
https://leetcode.com/problems/min-cost-to-connect-all-points/
v-1584.1 MST algorithm using Prims
START:
package solution;

import java.util.Arrays;

public class Solution {
    /**
     *  using minimum spanning tree - prims algorithm
     * @param points
     * @return
     */
    public int minCostConnectPoints(int[][] points) {
        int nPoints = points.length;
        int[] edgeWeigth = new int[nPoints];
        boolean[] isInMST = new boolean[nPoints];
        for (int i = 0; i < nPoints; i++) {
            isInMST[i] = false;
            edgeWeigth[i] = Integer.MAX_VALUE;
        }

        // setting starting point at 0
        edgeWeigth[0] = 0;

        for (int i = 0; i < nPoints; i++) {
            // i = 0, u is the first element
            int u = Solution.nextVertex(nPoints, edgeWeigth, isInMST);
            if (u == -1) {
                break;
            }
            isInMST[u] = true;
            int sourceX = points[u][0];
            int sourceY = points[u][1];
            for (int v = 0; v < nPoints; v++) {
                int desX = points[v][0];
                int desY = points[v][1];
                int distance = Math.abs(sourceX - desX) + Math.abs(sourceY - desY);
                if (u != v && isInMST[v] == false && distance < edgeWeigth[v]) {
                    edgeWeigth[v] = distance;
                }
            }
        }

        // calculate cost
        int minCost = 0;
        for (int i = 0; i < nPoints; i++) {
            minCost += edgeWeigth[i];
        }

        return minCost;
    }

    private static int nextVertex(int nPoints, int[] edgeWeigth, boolean[] inMST) {
        int min = Integer.MAX_VALUE, vertexIndex = -1;

        for (int v = 0; v < nPoints; v++) {
            if (inMST[v] == false && edgeWeigth[v] < min) {
                min = edgeWeigth[v];
                vertexIndex = v;
            }
        }
        return vertexIndex;
    }

    public static void mainBackup(String[] args) {
        // TODO code application logic here
        int[][] points = {{11, -6}, {9, -19}, {16, -13}, {4, -9}, {20, 4}, {20, 7}, {-9, 18}, {10, -15}, {-15, 3}, {6, 6}};
        Solution s = new Solution();
        int cost = s.minCostConnectPoints(points);
        System.out.println(cost);
    }
}

:END
v-1584.2 MST algorithm using Krushkals


Topics: Sliding Window
----------------------------
1052. Grumpy Bookstore Owner
https://leetcode.com/problems/grumpy-bookstore-owner/
v-1052.1
START:

class Solution {
    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
        int satisfiedCustomer = 0;
        int currentSum = this.getGrumpyCustomer(customers, grumpy, 0, minutes);
        int maxSum = currentSum;
        int lenCustomers = customers.length;
        int secretTechniqueStartingIndex = 0;

        for (int i = 0; i < lenCustomers; i++) {
            if (grumpy[i] == 0) {
                satisfiedCustomer += customers[i];
            }
        }
        // finding max only grumpy customers window
        for (int i = 1; i <= lenCustomers - minutes; i++) {
            if (grumpy[i - 1] == 1) {
                currentSum -= customers[i - 1];
            }

            if (grumpy[i + minutes - 1] == 1) {
                currentSum += customers[i + minutes - 1];
            }
            //System.out.println(maxGrumpyCustomersInWindow+ " " + currentWindowGrumpyCustomer);
            if (currentSum > maxSum ) {
                secretTechniqueStartingIndex = i;
                maxSum = currentSum;
            }
        }

        // add sliding windows secret ideas extra customer
        for (int i = secretTechniqueStartingIndex; i < (secretTechniqueStartingIndex + minutes) && i < lenCustomers; i++) {
            if (grumpy[i] == 1) {
                satisfiedCustomer += customers[i];
            }
        }

        //satisfiedCustomer += maxSum;
        return satisfiedCustomer;
    }

    public int getGrumpyCustomer(int[] grumpy, int[] customers, int startIndex, int endIndex) {
        int sum = 0;

        for (int i = startIndex; i < endIndex && i < grumpy.length; i++) {
            if (grumpy[i] == 1) {
                sum += customers[i];
            }
        }

        return sum;
    }
}
:END
v-1052.2 //satisfiedCustomer += maxSum;
