Topics: Maths
---------------
7. Reverse Integer
https://leetcode.com/problems/reverse-integer/
V7.1
class Solution {
    public int reverse(int x) {
        int minInt = -2147483648;
        int maxInt = 2147483647;
        int reversedNumber = 0;
        boolean isNegative = false;
        if (x < 0) {
            isNegative = true;
            x = -1 * x;
        }
        String org = String.valueOf(x);
        int indexLen = org.length() - 1;
        char[] revChars = new char[indexLen + 1];
        int i = 0;
        while (indexLen >= 0) {
            revChars[i++] = org.charAt(indexLen--);
        }
        //System.out.println(revChars);
        return this.getReversedNumber(revChars, isNegative);
    }

    public int charArrayToInteger(char[] array) {
        String arr = new String(array);
        int number = Integer.parseInt(arr);

        return number;
    }

    private int getReversedNumber(char[] revChars, boolean negative) {
        char[] maxNum = {'2', '1', '4', '7', '4', '8', '3', '6', '4', '7'};
        int numFlag = 1;
        if (negative) {
            maxNum[9] = '8';
            //System.out.println("Neg");
            numFlag = -1;
        }
        
        // length checking
        if (revChars.length > maxNum.length) {
            return 0;
        } else if (revChars.length < maxNum.length) {
            return  numFlag * this.charArrayToInteger(revChars);
        } else {
            //2147483647
            //2137483647
            int indexlen = maxNum.length;
            for (int i = 0; i < indexlen; i++) {
                if (maxNum[i] == revChars[i]) {
                    
                } else if (maxNum[i] > revChars[i]) {
                    return numFlag * this.charArrayToInteger(revChars);
                } else {
                    return 0;
                }
            }
        }
        return numFlag * this.charArrayToInteger(revChars);
    }
}

Topics: Tree
---------------------
226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
V226.1
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        TreeNode tempNode = root.left;
        root.left = root.right;
        root.right = tempNode;
        root.left = this.invertTree(root.left);
        root.right = this.invertTree(root.right);
        return root;
    }
}

Topics: DFS
---------------------
100. same Tree
https://leetcode.com/problems/same-tree/
V100.1
START:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        String pPath = this.traversePath(p);
        String qPath = this.traversePath(q);
        if (pPath.equals(qPath)) {
            return true;
        }
        return false;
    }
    
    private String traversePath(TreeNode node) {
        if (node == null) {
            return "N";
        }
        String leftNodesPath = this.traversePath(node.left);
        int currentPath = node.val;
        String rightNodesPath = this.traversePath(node.right);
        return leftNodesPath  + rightNodesPath + currentPath;
    }
}
:END

Topics: Greedy
---------------------
455. Assign Cookies
https://leetcode.com/problems/assign-cookies/
V455.1
START:
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int currentCookieIndex = 0;
        int gLen = g.length;
        int sLen = s.length;
        int contentChildNumber = 0;
        for (int i = 0; i < gLen && currentCookieIndex < sLen; i++) {
            if (g[i] <= s[currentCookieIndex]) {
                currentCookieIndex++;
                contentChildNumber++;
            } else {
                currentCookieIndex++;
                i--;
            }
        }
        return contentChildNumber;
    }
}
:END


Topics: HashTable
---------------------
205. Isomorphic Strings
https://leetcode.com/problems/isomorphic-strings/
V205.1
START:
class Solution {
    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> sMap = new HashMap<>();
        Map<Character, Character> tMap = new HashMap<>();
        int len = s.length();
        for (int i = 0; i < len; i++) {
            char sCh = s.charAt(i);
            char tCh = t.charAt(i);

            if (sMap.containsKey(sCh)) {
                if (tCh != sMap.get(sCh)) {
                    return false;
                }
            } else if (tMap.containsKey(tCh)) {
                return false;
            } else {
                sMap.put(sCh,tCh);
                tMap.put(tCh,sCh);
            }
        }
        return true;
    }
}
:END


Topics: Binary Search
---------------------
278. First Bad Version
https://leetcode.com/problems/first-bad-version/
V278.1 Time Limit excede
START:
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        // 1 2 3 -4 5
        int lastGoodVersion = 0;
        int lastBadVersion = n;

        while (lastBadVersion - lastGoodVersion != 1) {
            n = (lastBadVersion + lastGoodVersion) / 2;
            boolean isBad = isBadVersion(n);
            if (isBad) {
                lastBadVersion = n;
            } else {
                lastGoodVersion = n;
            }
        }
        return lastBadVersion;
    }
}
:END

V278.2 Accepted
START:
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
   public int firstBadVersion(int n) {
        // 1 2 3 -4 5
        int lastGoodVersion = 0; // could not be any good version
        int lastBadVersion = n;

        while (lastBadVersion - lastGoodVersion != 1) {
            //n = (lastBadVersion + lastGoodVersion) / 2;
            n = lastGoodVersion + (lastBadVersion - lastGoodVersion) / 2;
            boolean isBad = isBadVersion(n);
            if (isBad) {
                lastBadVersion = n;
            } else {
                lastGoodVersion = n;
            }
        }
        return lastBadVersion;
    }
}
:END

Topics: Breadth-First-Search
----------------------------
993. Cousins in Binary Tree
https://leetcode.com/problems/cousins-in-binary-tree/
V993.1
START:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        boolean executeLoop = true;
		boolean isCousins = false;
        while (executeLoop) {
            int currentLevelNodesNumber = q.size();
            if (currentLevelNodesNumber == 0) {
                break;
            }

            for (int i = 0; i < currentLevelNodesNumber; i++) {
                TreeNode curNode = q.remove();
                int[] tArr = new int[2];
                TreeNode leftNode = curNode.left;
                if (leftNode != null) {
                    q.add(leftNode);
                    tArr[0] = leftNode.val;
                }
                TreeNode rightNode = curNode.right;
                if (rightNode != null) {
                    q.add(rightNode);
                    tArr[1] = rightNode.val;
                }
                if (!executeLoop && this.isValueExists(tArr, x, y)) {
                    return true;
                } else if (this.isValueExists(tArr, x, y)) {
                    executeLoop = false; // perform search only in this level
                }
            }
        }
        return isCousins;
    }


    public boolean isValueExists(int[] arr, int x, int y) {
        for (int element : arr) {
            if (element == x || element == y) {
               return true;
            }
        }
        return false;
    }
}
V993.2 try recursively
V993.3 try using dfs
:END

Topics: Sort
----------------------------
1528. Shuffle String
https://leetcode.com/problems/shuffle-string/
V1528.1
START:
class Solution {
    public String restoreString(String s, int[] indices) {
        int len = indices.length;
        char[] newArr = new char[len];
        for (int i = 0; i < len; i++) {
            newArr[indices[i]] = s.charAt(i);
        }
        return String.valueOf(newArr);
    }
}
:END

Topics: Two Pointers
----------------------------
1800. Maximum Ascending Subarray Sum
https://leetcode.com/problems/maximum-ascending-subarray-sum/
V1800.1
START:
class Solution {
    public int maxAscendingSum(int[] nums) {
        int maxSum = 0;
        int tempSum = nums[0];
        int numlen = nums.length;

		for (int i = 1; i < numlen; i++) {
            if (nums[i] > nums[i-1]) {
                tempSum += nums[i];
            } else {
                if (tempSum > maxSum) {
                    maxSum = tempSum;
                }
                tempSum = nums[i];
            }
        }
        if (tempSum > maxSum) {
            maxSum = tempSum;
        }
        return maxSum;
    }
}
:END

Topics: Backtracking
----------------------------
1688. Count of Matches in Tournament
https://leetcode.com/problems/count-of-matches-in-tournament/
V1688.1
START:
class Solution {
    public int numberOfMatches(int n) {
        if (n == 1) {
            return 0;
        } else if (n == 2) {
            return 1;
        }
        return 1 + numberOfMatches(n-1);
    }
}
:END

Topics: Stack
----------------------------
1021. Remove Outermost Parentheses
https://leetcode.com/problems/remove-outermost-parentheses/
V1021.1
START:
class Solution {
    public String removeOuterParentheses(String S) {
        String sNew = "";
        Stack<Character> stack = new Stack<>();
        stack.push(S.charAt(0));
        int sLen = S.length();
        char startCh = '(';
        char endCh = ')';
        for (int i = 1; i < sLen; i++) {
            char ch = S.charAt(i);
            if (ch == startCh) {
                if (!stack.empty()) {
                    sNew += startCh;
                }
                stack.push(ch);
            } else {
                stack.pop();
                if (!stack.empty()) {
                    sNew += endCh;
                }
            }
        }
        return sNew;
    }
}
:END


Topics: Design
----------------------------
1603. Design Parking System
https://leetcode.com/problems/design-parking-system/
1603.1
START:
class ParkingSystem {
    private int big;
    private int medium;
    private int small;

    public ParkingSystem(int big, int medium, int small) {
        this.big = big;
        this.medium = medium;
        this.small = small;
    }

    public boolean addCar(int carType) {
        boolean isSlotsAvailable = false;

        switch(carType) {
            case 1:
                if (this.big > 0) {
                    this.big--;
                    isSlotsAvailable = true;
                }
                break;
            case 2:
                if (this.medium > 0) {
                    this.medium--;
                    isSlotsAvailable = true;
                }
                break;
            default:
                if (this.small > 0) {
                    this.small--;
                    isSlotsAvailable = true;
                }
        }
        return isSlotsAvailable;
    }
}

/**
 * Your ParkingSystem object will be instantiated and called as such:
 * ParkingSystem obj = new ParkingSystem(big, medium, small);
 * boolean param_1 = obj.addCar(carType);
 */
:END
1603.2 try using array



Topics: Bit Manipulation
Brush Up: https://www.baeldung.com/java-bitwise-operators
----------------------------
1342. Number of Steps to Reduce a Number to Zero
https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/
v-1342.1
START:
class Solution {
    public int numberOfSteps(int num) {
        int nSteps = 0;
        while (num != 0) {
            if ((num & 1) != 0) {
                // substract for even
                num--;
            } else {
                num = num >> 1;
            }
            nSteps++;
        }
        return nSteps;
    }
}
:END

Topics: Graph
----------------------------
997. Find the Town Judge
https://leetcode.com/problems/find-the-town-judge/
v-997.1
START:
class Solution {
    public int[][] prepareAdjacencyMatrix(int N, int[][] trust) {
        /*  Example 5:
            0	0	0	0	0	

            0	-1	0	1	1	

            0	0	-1	1	1	

            0	0	0	0	0	

            0	0	0	1	-1	
        */
        int[][] adjMarix = new int[N+1][N+1];
        int rows = trust.length;
        
        
        for (int i = 0; i < rows; i++) {
            adjMarix[trust[i][0]][trust[i][0]] = -1;
            for (int j = 1; j < trust[i].length; j++) {
                adjMarix[trust[i][0]][trust[i][j]] = 1;
            }
        }
        return adjMarix;
    }

    public int findJudge(int N, int[][] trust) {
        int[][] adjMatrix = this.prepareAdjacencyMatrix(N,trust);
        int judge = -1;
        
        // find who is not trusting anyone
        for (int i = 1; i < N + 1; i++) {
            if (adjMatrix[i][i] == 0) {
                judge = i;
                break;
            }
        }

        if (judge != -1) {
            // everyone must trust judge, else no judge
            for (int i = 1; i < N + 1; i++) {
                if (i != judge && adjMatrix[i][judge]==0) {
                    return -1;
                }
            }
        }

        return judge;
    }
}
:END

