Topics: Maths
---------------
7. Reverse Integer
https://leetcode.com/problems/reverse-integer/
V7.1
class Solution {
    public int reverse(int x) {
        int minInt = -2147483648;
        int maxInt = 2147483647;
        int reversedNumber = 0;
        boolean isNegative = false;
        if (x < 0) {
            isNegative = true;
            x = -1 * x;
        }
        String org = String.valueOf(x);
        int indexLen = org.length() - 1;
        char[] revChars = new char[indexLen + 1];
        int i = 0;
        while (indexLen >= 0) {
            revChars[i++] = org.charAt(indexLen--);
        }
        //System.out.println(revChars);
        return this.getReversedNumber(revChars, isNegative);
    }

    public int charArrayToInteger(char[] array) {
        String arr = new String(array);
        int number = Integer.parseInt(arr);

        return number;
    }

    private int getReversedNumber(char[] revChars, boolean negative) {
        char[] maxNum = {'2', '1', '4', '7', '4', '8', '3', '6', '4', '7'};
        int numFlag = 1;
        if (negative) {
            maxNum[9] = '8';
            //System.out.println("Neg");
            numFlag = -1;
        }
        
        // length checking
        if (revChars.length > maxNum.length) {
            return 0;
        } else if (revChars.length < maxNum.length) {
            return  numFlag * this.charArrayToInteger(revChars);
        } else {
            //2147483647
            //2137483647
            int indexlen = maxNum.length;
            for (int i = 0; i < indexlen; i++) {
                if (maxNum[i] == revChars[i]) {
                    
                } else if (maxNum[i] > revChars[i]) {
                    return numFlag * this.charArrayToInteger(revChars);
                } else {
                    return 0;
                }
            }
        }
        return numFlag * this.charArrayToInteger(revChars);
    }
}

Topics: Tree
---------------------
226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
V226.1
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        TreeNode tempNode = root.left;
        root.left = root.right;
        root.right = tempNode;
        root.left = this.invertTree(root.left);
        root.right = this.invertTree(root.right);
        return root;
    }
}

Topics: DFS
---------------------
100. same Tree
https://leetcode.com/problems/same-tree/
V100.1
START:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        String pPath = this.traversePath(p);
        String qPath = this.traversePath(q);
        if (pPath.equals(qPath)) {
            return true;
        }
        return false;
    }
    
    private String traversePath(TreeNode node) {
        if (node == null) {
            return "N";
        }
        String leftNodesPath = this.traversePath(node.left);
        int currentPath = node.val;
        String rightNodesPath = this.traversePath(node.right);
        return leftNodesPath  + rightNodesPath + currentPath;
    }
}
:END

Topics: Greedy
---------------------
455. Assign Cookies
https://leetcode.com/problems/assign-cookies/
V455.1
START:
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int currentCookieIndex = 0;
        int gLen = g.length;
        int sLen = s.length;
        int contentChildNumber = 0;
        for (int i = 0; i < gLen && currentCookieIndex < sLen; i++) {
            if (g[i] <= s[currentCookieIndex]) {
                currentCookieIndex++;
                contentChildNumber++;
            } else {
                currentCookieIndex++;
                i--;
            }
        }
        return contentChildNumber;
    }
}
:END


Topics: HashTable
---------------------
205. Isomorphic Strings
https://leetcode.com/problems/isomorphic-strings/
V205.1
START:
class Solution {
    public boolean isIsomorphic(String s, String t) {
        Map<Character, Character> sMap = new HashMap<>();
        Map<Character, Character> tMap = new HashMap<>();
        int len = s.length();
        for (int i = 0; i < len; i++) {
            char sCh = s.charAt(i);
            char tCh = t.charAt(i);

            if (sMap.containsKey(sCh)) {
                if (tCh != sMap.get(sCh)) {
                    return false;
                }
            } else if (tMap.containsKey(tCh)) {
                return false;
            } else {
                sMap.put(sCh,tCh);
                tMap.put(tCh,sCh);
            }
        }
        return true;
    }
}
:END


Topics: Binary Search
---------------------
278. First Bad Version
https://leetcode.com/problems/first-bad-version/
V278.1 Time Limit excede
START:
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        // 1 2 3 -4 5
        int lastGoodVersion = 0;
        int lastBadVersion = n;

        while (lastBadVersion - lastGoodVersion != 1) {
            n = (lastBadVersion + lastGoodVersion) / 2;
            boolean isBad = isBadVersion(n);
            if (isBad) {
                lastBadVersion = n;
            } else {
                lastGoodVersion = n;
            }
        }
        return lastBadVersion;
    }
}
:END

V278.2 Accepted
START:
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
   public int firstBadVersion(int n) {
        // 1 2 3 -4 5
        int lastGoodVersion = 0; // could not be any good version
        int lastBadVersion = n;

        while (lastBadVersion - lastGoodVersion != 1) {
            //n = (lastBadVersion + lastGoodVersion) / 2;
            n = lastGoodVersion + (lastBadVersion - lastGoodVersion) / 2;
            boolean isBad = isBadVersion(n);
            if (isBad) {
                lastBadVersion = n;
            } else {
                lastGoodVersion = n;
            }
        }
        return lastBadVersion;
    }
}
:END

Topics: Breadth-First-Search
----------------------------
993. Cousins in Binary Tree
https://leetcode.com/problems/cousins-in-binary-tree/
V993.1
START:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        boolean executeLoop = true;
		boolean isCousins = false;
        while (executeLoop) {
            int currentLevelNodesNumber = q.size();
            if (currentLevelNodesNumber == 0) {
                break;
            }

            for (int i = 0; i < currentLevelNodesNumber; i++) {
                TreeNode curNode = q.remove();
                int[] tArr = new int[2];
                TreeNode leftNode = curNode.left;
                if (leftNode != null) {
                    q.add(leftNode);
                    tArr[0] = leftNode.val;
                }
                TreeNode rightNode = curNode.right;
                if (rightNode != null) {
                    q.add(rightNode);
                    tArr[1] = rightNode.val;
                }
                if (!executeLoop && this.isValueExists(tArr, x, y)) {
                    return true;
                } else if (this.isValueExists(tArr, x, y)) {
                    executeLoop = false; // perform search only in this level
                }
            }
        }
        return isCousins;
    }


    public boolean isValueExists(int[] arr, int x, int y) {
        for (int element : arr) {
            if (element == x || element == y) {
               return true;
            }
        }
        return false;
    }
}
V993.2 try recursively
V993.3 try using dfs
:END

Topics: Sort
----------------------------
1528. Shuffle String
https://leetcode.com/problems/shuffle-string/
V1528.1
START:
class Solution {
    public String restoreString(String s, int[] indices) {
        int len = indices.length;
        char[] newArr = new char[len];
        for (int i = 0; i < len; i++) {
            newArr[indices[i]] = s.charAt(i);
        }
        return String.valueOf(newArr);
    }
}
:END

Topics: Two Pointers
----------------------------
1800. Maximum Ascending Subarray Sum
https://leetcode.com/problems/maximum-ascending-subarray-sum/
V1800.1
START:
class Solution {
    public int maxAscendingSum(int[] nums) {
        int maxSum = 0;
        int tempSum = nums[0];
        int numlen = nums.length;

		for (int i = 1; i < numlen; i++) {
            if (nums[i] > nums[i-1]) {
                tempSum += nums[i];
            } else {
                if (tempSum > maxSum) {
                    maxSum = tempSum;
                }
                tempSum = nums[i];
            }
        }
        if (tempSum > maxSum) {
            maxSum = tempSum;
        }
        return maxSum;
    }
}
:END

Topics: Backtracking
----------------------------
1688. Count of Matches in Tournament
https://leetcode.com/problems/count-of-matches-in-tournament/
V1688.1
START:
class Solution {
    public int numberOfMatches(int n) {
        if (n == 1) {
            return 0;
        } else if (n == 2) {
            return 1;
        }
        return 1 + numberOfMatches(n-1);
    }
}
:END

Topics: Stack
----------------------------
1021. Remove Outermost Parentheses
https://leetcode.com/problems/remove-outermost-parentheses/
V1021.1
START:
class Solution {
    public String removeOuterParentheses(String S) {
        String sNew = "";
        Stack<Character> stack = new Stack<>();
        stack.push(S.charAt(0));
        int sLen = S.length();
        char startCh = '(';
        char endCh = ')';
        for (int i = 1; i < sLen; i++) {
            char ch = S.charAt(i);
            if (ch == startCh) {
                if (!stack.empty()) {
                    sNew += startCh;
                }
                stack.push(ch);
            } else {
                stack.pop();
                if (!stack.empty()) {
                    sNew += endCh;
                }
            }
        }
        return sNew;
    }
}
:END


Topics: Design
----------------------------
1603. Design Parking System
https://leetcode.com/problems/design-parking-system/
1603.1
START:
class ParkingSystem {
    private int big;
    private int medium;
    private int small;

    public ParkingSystem(int big, int medium, int small) {
        this.big = big;
        this.medium = medium;
        this.small = small;
    }

    public boolean addCar(int carType) {
        boolean isSlotsAvailable = false;

        switch(carType) {
            case 1:
                if (this.big > 0) {
                    this.big--;
                    isSlotsAvailable = true;
                }
                break;
            case 2:
                if (this.medium > 0) {
                    this.medium--;
                    isSlotsAvailable = true;
                }
                break;
            default:
                if (this.small > 0) {
                    this.small--;
                    isSlotsAvailable = true;
                }
        }
        return isSlotsAvailable;
    }
}

/**
 * Your ParkingSystem object will be instantiated and called as such:
 * ParkingSystem obj = new ParkingSystem(big, medium, small);
 * boolean param_1 = obj.addCar(carType);
 */
:END
1603.2 try using array



Topics: Bit Manipulation
Brush Up: https://www.baeldung.com/java-bitwise-operators
----------------------------
1342. Number of Steps to Reduce a Number to Zero
https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/
v-1342.1
START:
class Solution {
    public int numberOfSteps(int num) {
        int nSteps = 0;
        while (num != 0) {
            if ((num & 1) != 0) {
                // substract for even
                num--;
            } else {
                num = num >> 1;
            }
            nSteps++;
        }
        return nSteps;
    }
}
:END

Topics: Graph
----------------------------
997. Find the Town Judge
https://leetcode.com/problems/find-the-town-judge/
v-997.1
START:
class Solution {
    public int[][] prepareAdjacencyMatrix(int N, int[][] trust) {
        /*  Example 5:
            0	0	0	0	0	

            0	-1	0	1	1	

            0	0	-1	1	1	

            0	0	0	0	0	

            0	0	0	1	-1	
        */
        int[][] adjMarix = new int[N+1][N+1];
        int rows = trust.length;
        
        
        for (int i = 0; i < rows; i++) {
            adjMarix[trust[i][0]][trust[i][0]] = -1;
            for (int j = 1; j < trust[i].length; j++) {
                adjMarix[trust[i][0]][trust[i][j]] = 1;
            }
        }
        return adjMarix;
    }

    public int findJudge(int N, int[][] trust) {
        int[][] adjMatrix = this.prepareAdjacencyMatrix(N,trust);
        int judge = -1;
        
        // find who is not trusting anyone
        for (int i = 1; i < N + 1; i++) {
            if (adjMatrix[i][i] == 0) {
                judge = i;
                break;
            }
        }

        if (judge != -1) {
            // everyone must trust judge, else no judge
            for (int i = 1; i < N + 1; i++) {
                if (i != judge && adjMatrix[i][judge]==0) {
                    return -1;
                }
            }
        }

        return judge;
    }
}
:END
v-997.2 Review


Topics: Heap
----------------------------
1046. Last Stone Weight
https://leetcode.com/problems/last-stone-weight/
v-1046.1
START:
class Solution {
    private static int currentItems = 0;

    public static int[] heapArray(int[] stones) {
        int[] heapArray = new int[stones.length];

        // sorting array
        for (int i = 0; i < stones.length; i++) {
            heapArray = insertAsHeapArray(heapArray,stones[i]);
            System.out.println(Arrays.toString(heapArray));
        }
       // System.out.println(Arrays.toString(heapArray));
        return heapArray;
    }

    public static int[] insertAsHeapArray(int[] arr, int element) {
        // finding right place to insert element
        int index = currentItems;

        for (int i = 0; i < currentItems; i++) {
            if (arr[i] > element) {
                index = i;
                break;
            }
        }

        // trickle up the rest of array elements
        currentItems++;
        for (int i = currentItems -1; i > index ; i--) {
            arr[i] = arr[i-1];
        }

        // insert element in right place
        arr[index] = element;

        return arr;
    }

    public static int remove(int[] arr) {
        if (currentItems == 0) {
            return 0;
        }
        return arr[--currentItems];
    }

    public static boolean isLast() {
        return currentItems == 1;
    }

    public int lastStoneWeight(int[] stones) {
        int[] heapArray = heapArray(stones);
        while (currentItems > 1) {
            int larger = remove(heapArray);
            int smaller = remove(heapArray);
            if (larger - smaller > 0) {
                insertAsHeapArray(heapArray, larger-smaller);
            }
        }
        return remove(heapArray);
    }
}
:END
v-1046.2 use built in PriorityQ library class

Topics: Linked List
----------------------------
876. Middle of the Linked List
https://leetcode.com/problems/middle-of-the-linked-list/
v-876.1
START:
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode mid = head;
        ListNode jumper = head;

        while (jumper != null && jumper.next != null) {
            jumper = jumper.next.next;
            mid = mid.next;
        }
        return mid;
    }
}
:END

Topics: Recursion
----------------------------
1137. N-th Tribonacci Number
https://leetcode.com/problems/n-th-tribonacci-number/
v-1137.1
START:
class Solution {
    private Map<Integer,Integer> map = new HashMap<>();
    public int tribonacci(int n) {
        if (n < 3) {
            if (n == 0) {
                return 0;
            } else if(n == 1 || n == 2) {
                return 1;
            }
        }

        if (!map.containsKey(n)) {
            map.put(n, this.tribonacci(n - 1) +  this.tribonacci(n - 2) + this.tribonacci(n - 3));
        }

        return map.get(n);
    }
}
:END
v-1137.2 Try without recursion

Topics: Union Find
----------------------------
1584. Min Cost to Connect All Points
https://leetcode.com/problems/min-cost-to-connect-all-points/
v-1584.1 MST algorithm using Prims
START:
package solution;

import java.util.Arrays;

public class Solution {
    /**
     *  using minimum spanning tree - prims algorithm
     * @param points
     * @return
     */
    public int minCostConnectPoints(int[][] points) {
        int nPoints = points.length;
        int[] edgeWeigth = new int[nPoints];
        boolean[] isInMST = new boolean[nPoints];
        for (int i = 0; i < nPoints; i++) {
            isInMST[i] = false;
            edgeWeigth[i] = Integer.MAX_VALUE;
        }

        // setting starting point at 0
        edgeWeigth[0] = 0;

        for (int i = 0; i < nPoints; i++) {
            // i = 0, u is the first element
            int u = Solution.nextVertex(nPoints, edgeWeigth, isInMST);
            if (u == -1) {
                break;
            }
            isInMST[u] = true;
            int sourceX = points[u][0];
            int sourceY = points[u][1];
            for (int v = 0; v < nPoints; v++) {
                int desX = points[v][0];
                int desY = points[v][1];
                int distance = Math.abs(sourceX - desX) + Math.abs(sourceY - desY);
                if (u != v && isInMST[v] == false && distance < edgeWeigth[v]) {
                    edgeWeigth[v] = distance;
                }
            }
        }

        // calculate cost
        int minCost = 0;
        for (int i = 0; i < nPoints; i++) {
            minCost += edgeWeigth[i];
        }

        return minCost;
    }

    private static int nextVertex(int nPoints, int[] edgeWeigth, boolean[] inMST) {
        int min = Integer.MAX_VALUE, vertexIndex = -1;

        for (int v = 0; v < nPoints; v++) {
            if (inMST[v] == false && edgeWeigth[v] < min) {
                min = edgeWeigth[v];
                vertexIndex = v;
            }
        }
        return vertexIndex;
    }

    public static void mainBackup(String[] args) {
        // TODO code application logic here
        int[][] points = {{11, -6}, {9, -19}, {16, -13}, {4, -9}, {20, 4}, {20, 7}, {-9, 18}, {10, -15}, {-15, 3}, {6, 6}};
        Solution s = new Solution();
        int cost = s.minCostConnectPoints(points);
        System.out.println(cost);
    }
}

:END
v-1584.2 MST algorithm using Krushkals


Topics: Sliding Window
----------------------------
1052. Grumpy Bookstore Owner
https://leetcode.com/problems/grumpy-bookstore-owner/
v-1052.1
START:

class Solution {
    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
        int satisfiedCustomer = 0;
        int currentSum = this.getGrumpyCustomer(customers, grumpy, 0, minutes);
        int maxSum = currentSum;
        int lenCustomers = customers.length;
        int secretTechniqueStartingIndex = 0;

        for (int i = 0; i < lenCustomers; i++) {
            if (grumpy[i] == 0) {
                satisfiedCustomer += customers[i];
            }
        }
        // finding max only grumpy customers window
        for (int i = 1; i <= lenCustomers - minutes; i++) {
            if (grumpy[i - 1] == 1) {
                currentSum -= customers[i - 1];
            }

            if (grumpy[i + minutes - 1] == 1) {
                currentSum += customers[i + minutes - 1];
            }
            //System.out.println(maxGrumpyCustomersInWindow+ " " + currentWindowGrumpyCustomer);
            if (currentSum > maxSum ) {
                secretTechniqueStartingIndex = i;
                maxSum = currentSum;
            }
        }

        // add sliding windows secret ideas extra customer
        for (int i = secretTechniqueStartingIndex; i < (secretTechniqueStartingIndex + minutes) && i < lenCustomers; i++) {
            if (grumpy[i] == 1) {
                satisfiedCustomer += customers[i];
            }
        }

        //satisfiedCustomer += maxSum;
        return satisfiedCustomer;
    }

    public int getGrumpyCustomer(int[] grumpy, int[] customers, int startIndex, int endIndex) {
        int sum = 0;

        for (int i = startIndex; i < endIndex && i < grumpy.length; i++) {
            if (grumpy[i] == 1) {
                sum += customers[i];
            }
        }

        return sum;
    }
}
:END
v-1052.2 //satisfiedCustomer += maxSum;


Topics: Trie
----------------------------
720. Longest Word in Dictionary
https://leetcode.com/problems/longest-word-in-dictionary/
v-720.1
START:
class Node {

    private Node[] childs;
    private boolean isEndOfWord;
    private char label;

    public Node() {
        this.childs = new Node[26]; //working with a-z characters
        this.isEndOfWord = false;
        for (int i = 0; i < 26; i++) {
            this.childs[i] = null;
        }
    }

    public Node(char ch) {
        this();
        this.label = ch;
    }

    public Node[] getChilds() {
        return this.childs;
    }

    public char getLabel() {
        return this.label;
    }

    public boolean isIsEndOfWord() {
        return this.isEndOfWord;
    }

    public void setIsEndOfWord(boolean isEndOfWord) {
        this.isEndOfWord = isEndOfWord;
    }
}

class Trie {

    private Node root;

    public Trie() {
        this.root = new Node();
    }

    public void insert(String str) {
        Node current = this.root;
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            Node n = this.getCharNode(current, ch);
            if (n == null) {
                // times to add characters
                current = this.insertChar(current, ch);
            } else {
                current = n;
            }
        }
        current.setIsEndOfWord(true);
    }

    public boolean isExist(String str) {
        Node current = this.root;
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            current = this.getCharNode(current, ch);
            if (current == null) {
                return false;
            }
            //System.out.print(current.getLabel() + ",");
        }
        //System.out.println();
        return current.isIsEndOfWord();
    }

   public boolean isIncrementalWord(String str) {
        Node current = this.root;
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            current = this.getCharNode(current, ch);
            if (current == null || !current.isIsEndOfWord()) {
                return false;
            }
            //System.out.print(current.getLabel() + ",");
        }
        //System.out.println();
        return current.isIsEndOfWord();
    }

    /**
     * if char is present in current childs then return the child node
     *
     * @param current searching for ch node of its childs
     * @param ch
     * @return
     */
    private Node getCharNode(Node current, char ch) {
        int nodeIndex = this.generateNodeIndex(ch);
        return current.getChilds()[nodeIndex];
    }

    private Node insertChar(Node current, char ch) {
        int nodeIndex = this.generateNodeIndex(ch);
        current.getChilds()[nodeIndex] = new Node(ch);
        return current.getChilds()[nodeIndex];
    }

    private int generateNodeIndex(char ch) {
        return (int) ch - 97;
    }
}

class Solution {
    public String longestWord(String[] words) {
        Trie trie = new Trie();
        Arrays.sort(words, Comparator.comparingInt(String::length));
        for (int i = 0; i < words.length; i++) {
            trie.insert(words[i]);
        }
        String longestStr = "";
        for (int i = words.length - 1; i >= 0; i--) {
            String str = words[i];
            //System.out.println(str);
            if (str.length() >= longestStr.length() && trie.isIncrementalWord(str)) {
                //System.out.println(longestStr + " " + str + " com-> " + longestStr.compareTo(str));
                if (longestStr.compareTo(str) > 0 || longestStr.isEmpty()) {
                    longestStr = str;
                }
            }
        }
        return longestStr;
    }
}
// input: ["vsw","vs","zwu","vsx","nc","o","vswus","orv","imf","i","v","zw","vs"]
:END
v-720.2 Use HashMap/HashSet


Topics: Divide and Conquer
----------------------------
169. Majority Element
Tags: [Arrays, Divide and Conquer, Bit Manipulation]
https://leetcode.com/problems/majority-element/
v-169.1 Divide and Conquer
START:
public class Solution {

    private Map<Integer, Integer> counting = new HashMap<>();

    public int majorityElement(int[] nums) {
        return this.recMajorityElement(nums, 0, nums.length - 1);
    }

    private int recMajorityElement(int[] nums, int start, int end) {
        if (start == end) {
            // incrementing number count
            if (this.counting.containsKey(nums[start])) {
                this.counting.put(nums[start], this.counting.get(nums[start]) + 1);
            } else {
                this.counting.put(nums[start], 1);
            }

            return nums[start];
        }
        int mid = start + (end - start) / 2;
        int left = this.recMajorityElement(nums, start, mid);
        int right = this.recMajorityElement(nums, mid + 1, end);
        int number = 0;
        if (left == right) {
            number = left;
        } else {
            int leftCount = 0;
            if (this.counting.containsKey(left)) {
                leftCount = this.counting.get(left);
            }
            int rightCount = 0;
            if (this.counting.containsKey(right)) {
                rightCount = this.counting.get(right);
            }
            if (leftCount > rightCount) {
                number = left;
            } else if (rightCount > leftCount) {
                number = right;
            }
        }

        return number;
    }
}
:END

v-169.2 Boyer Moore Majority Vote Algorithm
v-169.3 hashmap -> hint: add element and count, if major immediately return
v-169.4 Bit Manipulation


Topics: Segment Tree
----------------------------
307. Range Sum Query - Mutable
Tags: [Binary index Tree, Segment Tree]
https://leetcode.com/problems/range-sum-query-mutable/
v-307.1 Segment Tree
START:
class NumArray {
    private int segmentTree[];
    private int arrLength = 0;
    private int[] arr;

    public NumArray(int[] nums) {
        this.arr = nums;
        int len = nums.length * 3;
        this.arrLength = nums.length;
        this.segmentTree = new int[len];//java, all cells default value is 0
        this.recBuildTree(this.arr, 0, 0, this.arrLength - 1);
    }

    private int recBuildTree(int[] arr, int currentNode, int leftNodeIndex, int rightNodeIndex) {
        if (leftNodeIndex == rightNodeIndex) {
            this.segmentTree[currentNode] = arr[leftNodeIndex];
            return arr[leftNodeIndex];
        }
        int midIndex = leftNodeIndex + (rightNodeIndex - leftNodeIndex) / 2;
        int leftNode = currentNode * 2 + 1;
        int rightNode = currentNode * 2 + 2;
        int leftSideSum = this.recBuildTree(arr, leftNode, leftNodeIndex, midIndex);
        int rightSideSum = this.recBuildTree(arr, rightNode, midIndex + 1, rightNodeIndex);
        return this.segmentTree[currentNode] = leftSideSum + rightSideSum;
    }

    public void update(int index, int val) {
        int oldValue = this.arr[index];
        this.arr[index] = val;
        int diff = val - oldValue;
        int leftIndex = 0;
        int rightIndex = this.arrLength - 1;
        this.recUpdate(this.segmentTree, 0, index, diff, leftIndex, rightIndex);
    }
    
    private void recUpdate(int[] segmentTree, int currentNode, int updateIndex, int diff, int leftIndex, int rightIndex) {
        if (leftIndex == rightIndex && updateIndex == leftIndex) {
            this.segmentTree[currentNode] = this.segmentTree[currentNode] + diff;
            return;
        }

        if (updateIndex < leftIndex || rightIndex < updateIndex) {
            return;
        }
        int midIndex = leftIndex + (rightIndex - leftIndex) / 2;
        int leftNode = currentNode * 2 + 1;
        int rightNode = currentNode * 2 + 2;
        this.recUpdate(segmentTree, leftNode, updateIndex, diff, leftIndex, midIndex);
        this.recUpdate(segmentTree, rightNode, updateIndex, diff, midIndex + 1, rightIndex);
        this.segmentTree[currentNode] = this.segmentTree[currentNode] + diff;
    }

    public int sumRange(int left, int right) {
        return this.query(left, right);
    }

    private int query(int rangeIndex1, int rangeIndex2) {
        // checking whether range 
        int leftTreeIndex = 0;
        int rightTreeIndex = this.arrLength - 1;
        int currentNode = 0;
        int sum = this.recQuery(rangeIndex1, rangeIndex2, currentNode, leftTreeIndex, rightTreeIndex);
        //System.out.println("Sum: " + sum);
        return sum;
    }
    
    private int recQuery(int rangeIndex1, int rangeIndex2, int currentNode, int leftTreeIndex, int rightTreeIndex) {
        // range check query
        if (rangeIndex1 > rightTreeIndex || rangeIndex2 < leftTreeIndex) {
            return 0;
        } else if ((rangeIndex1 <= leftTreeIndex) && (rightTreeIndex <= rangeIndex2)) {
            return this.segmentTree[currentNode];
        }
        int midIndex = leftTreeIndex + (rightTreeIndex - leftTreeIndex) / 2;
        int leftNode = currentNode * 2 + 1;
        int rightNode = currentNode * 2 + 2;
        int leftSum = this.recQuery(rangeIndex1, rangeIndex2, leftNode, leftTreeIndex, midIndex);
        int rightSum = this.recQuery(rangeIndex1, rangeIndex2, rightNode, midIndex + 1, rightTreeIndex);
        return leftSum + rightSum;
    }
    
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(index,val);
 * int param_2 = obj.sumRange(left,right);
 */
:END
v-307.2 Binary Indexed Tree


Topics: Ordered Map
-------------------
846. Hand of Straights
Tags: [Ordered Map]
https://leetcode.com/problems/hand-of-straights/
v-846.1 TreeMap
START:
class Solution {
    public boolean isNStraightHand(int[] hand, int groupSize) {
        // primary numbering check
        if (hand.length % groupSize != 0) {
            return false;
        }

        TreeMap<Integer, Integer> tree_map = new TreeMap<Integer, Integer>();
        for (int i = 0; i < hand.length; i++) {
            int counter = 0;
            if (tree_map.containsKey(hand[i])) {
                counter = tree_map.get(hand[i]);
            }
            counter = counter + 1;
            tree_map.put(hand[i], counter);
        }

        while (true) {
            tree_map = this.test(tree_map, groupSize);
            if (tree_map == null) {
                return false;
            } else if (tree_map.size() == 0) {
                break;
            }
        }
        return true;
    }

    private TreeMap<Integer, Integer> test(TreeMap<Integer, Integer> tree_map, int groupSize) {
        int[] removeKey = new int[groupSize];
        int rNum = 0;
        for (Map.Entry<Integer, Integer> map : tree_map.entrySet()) {
            int key = map.getKey();
            int keyCounter = map.getValue();
            if (keyCounter == 1) {
                removeKey[rNum] = key;
                rNum++;
            } else {
                tree_map.put(key, keyCounter - 1);
            }
            int nextKey = key + 1;
            for (int i = 1; i < groupSize; i++) {

                if (tree_map.containsKey(nextKey)) {
                    keyCounter = tree_map.get(nextKey);
                    if (keyCounter == 1) {
                        removeKey[rNum] = nextKey;
                        rNum++;
                    } else {
                        tree_map.put(nextKey, keyCounter - 1);
                    }
                } else {
                    return null;
                }
                nextKey++;
            }
            break;
        }

        // update tree_map
        for (int i = 0; i < rNum; i++) {
            tree_map.remove(removeKey[i]);
        }
        return tree_map;
    }
}
:END

Topics: Queue
----------------------
933. Number of Recent Calls
Tags: []
https://leetcode.com/problems/number-of-recent-calls/
v-933.1 Accepted
START:
class RecentCounter {
    private int[] counters;
    private int startIndex;
    private int curIndex;

    public RecentCounter() {
        this.counters = new int[10000];
        this.startIndex = 0;
        this.curIndex = -1;
    }

    public int ping(int t) {
        this.curIndex++;
        this.counters[this.curIndex] = t;
        int startCounterValue = t - 3000;
        while (this.counters[this.startIndex] < startCounterValue && this.startIndex <= this.curIndex) {
            this.startIndex++;
        }
        int counter = this.curIndex - this.startIndex + 1;
        return counter;
    }
}

/**
 * Your RecentCounter object will be instantiated and called as such:
 * RecentCounter obj = new RecentCounter();
 * int param_1 = obj.ping(t);
 */
 :END
 v-933.2 (Solution) Use LinkedList
 v-933.3 (SolutionDiscussion) Array with Binary Search


Topics: Geometry
----------------------
1266. Minimum Time Visiting All Points
Tags: [Array, Geometry]
https://leetcode.com/problems/minimum-time-visiting-all-points/
v-1266.1
START:
class Solution {
    public int minTimeToVisitAllPoints(int[][] points) {
        int totalDistance = 0;
        int srcX = points[0][0];
        int srcY = points[0][1];
        for(int i = 1; i< points.length; i++) {
            int desX  = points[i][0];
            int desY = points[i][1];
            int diffX = Math.abs(srcX - desX);
            int diffY = Math.abs(srcY - desY);
            int minDif = Math.min(diffX,diffY);
            if (minDif == 0) {
                minDif = Math.max(diffX,diffY);
            }
            totalDistance += minDif + Math.max(diffX,diffY) - minDif; // rethink
            //totalDistance += Math.max(diffX,diffY); // enough
            srcX = desX;
            srcY = desY;
        }
        return totalDistance;
    }
}
:END

Topics: Line Sweep
----------------------
1288. Remove Covered Intervals
Tags: [Greedy, Sort, Line Sweep]
https://leetcode.com/problems/remove-covered-intervals/
v-1288.1 Brute Force
START:
class Solution {
    public int removeCoveredIntervals(int[][] intervals) {
        int totalIntervals = intervals.length;
        int[] coveredIntervals = new int[intervals.length];

        for (int i = 0; i < intervals.length; i++) {
            if (coveredIntervals[i] == 1) {
                continue;
            }
            int c = intervals[i][0];
            int d = intervals[i][1];
            for (int j = i + 1; j < intervals.length; j++) {
                if (coveredIntervals[j] == 1) {
                    continue;
                }
                int a = intervals[j][0];
                int b = intervals[j][1];

                if (c <= a && b <= d) {
                    coveredIntervals[j] = 1;
                    totalIntervals--;
                } else if (a <= c && d <= b) {
                    coveredIntervals[i] = 1;
                    totalIntervals--;
                    break;
                }
            }
        }
        return totalIntervals;
    }
}
:END
v-1288.2 sort


Input:
[-1,-2]
Output:
[-2,0]
Expected:
[1,0]



Topics: Binary Indexed Tree
---------------------------
327. Count of Range Sum
Tags:
https://leetcode.com/problems/count-of-range-sum/
v-327.1 Binary Indexed Tree Time Limit Exit
START:
public class Solution {

    private int[] arr;
    private int[] biTreeArr;

    public int countRangeSum(int[] nums, int lower, int upper) {
        this.arr = nums;
        //System.out.println(Arrays.toString(this.arr));
        this.biTreeArr = new int[this.arr.length + 1];// all elements value is 0
        this.buildBinaryIndexedTree();
        //System.out.println(Arrays.toString(this.arr));
        //System.out.println(Arrays.toString(this.biTreeArr));

        return this.rangeCount(lower, upper);
    }

    private int rangeCount(int lower, int upper) {
        long[] table = this.getTable();
        int rangeCount = 0;
        //System.out.println(Arrays.toString(table));
        for (int i = 0; i < this.arr.length; i++) {
            //System.out.println("i->" + i);
            if (lower <= table[i] && table[i] <= upper) {
                rangeCount++;
            }
            for (int j = i + 1; j < this.arr.length; j++) {
                long rangeSum = table[j] - table[i];
                //System.out.println(rangeSum);
                if (lower <= rangeSum && rangeSum <= upper) {
                    rangeCount++;
                }
                //System.out.println("rangeCount:" + rangeCount);
            }
        }
        return rangeCount;
    }

    private long[] getTable() {
        long[] table = new long[this.arr.length];
        table[0] = this.arr[0];
        for (int i = 1; i < this.arr.length; i++) {
            //table[i] = this.getSum(i);
            table[i] = table[i-1] + this.arr[i];
        }

        return table;
    }

    private void buildBinaryIndexedTree() {
        //System.out.println("Preparing BI tree");
        for (int i = 0; i < this.arr.length; i++) {
            this.updateBinaryIndexedTree(this.arr.length, i, this.arr[i]);
        }
        //System.out.println("BI Array:" + Arrays.toString(this.biTreeArr));
    }

    private void updateBinaryIndexedTree(int n, int index, int val) {
        //update original array first
        //this.arr[index] += val;

        index = index + 1;
        // Traverse all ancestors and add 'val'
        while (index <= n) {
            // Add 'val' to current node of BIT Tree
            this.biTreeArr[index] += val;
            // assign child index
            index += index & (-index);
        }
    }

    long getSum(int index) {
        //System.out.println("++++getSum++++ index=" + index);
        //System.out.println("BI Array:" + Arrays.toString(this.biTreeArr));
        long sum = 0;
        // index in this.biTreeArr[] is 1 more than the index in arr[]
        index = index + 1;

        // Traverse ancestors of this.biTreeArr[index]
        while (index > 0) {
            //System.out.print("indx:" + index + ", ");
            sum += this.biTreeArr[index];
            // assign child index
            index -= index & (-index);
        }
        //System.out.println("\nsum :" + sum);
        //System.out.println("---- getSum ----");
        return sum;
    }

    //computing the sum of a range
    public long getSum(int startIndex, int endIndex) {
        //System.out.println("++++ rangeSum +++++");
        long rangeSum = (this.getSum(endIndex) - this.getSum(startIndex - 1));
        //System.out.println("rangeSum: " + rangeSum);
        //System.out.println("--- rangeSum ---");
        return rangeSum;
    }

    public static void main(String[] args) {
        // TODO code application logic here
        //int arr[] = {2, 1, 1, 3, 2, 3};
        //int arr[] = {-2,5,-1};
        int arr[] = {-2147483647, 0, -2147483647, 2147483647}; //3: -564, 3864
        Solution solution = new Solution();
        int c = solution.countRangeSum(arr, -564, 3864);
        System.out.println(c);
    }
}
:END

315. Count of Smaller Numbers After Self
Tags: [Greedy, Sort, Line Sweep]
https://leetcode.com/problems/remove-covered-intervals/
v-315.1 FAILS
START:
:END

Topics: Brain Teasures
----------------------
521. Longest Uncommon Subsequence I
Tags:[brain Teasures, String]
https://leetcode.com/problems/longest-uncommon-subsequence-i/
v-521.1
START:
class Solution {
    public int findLUSlength(String a, String b) {
        int aLen = a.length();
        int bLen = b.length();
        int maxUncommonSubSequence = 0;
        if (aLen == bLen) {
            if (a.equals(b)) {
                maxUncommonSubSequence = -1;
            } else {
                maxUncommonSubSequence = aLen;
            }
        } else {
            maxUncommonSubSequence = Math.max(aLen,bLen);
        }
        return maxUncommonSubSequence;
    }
}
:END

v-521.2
START:
class Solution {
    public int findLUSlength(String a, String b) {
        if (a.equals(b)) {
            return -1;
        } 
        return Math.max(a.length(), b.length());
    }
}
:END
v-521.3 Brute force idea by generating all subsequence


Topics :Topological Sort
207. Course Schedule
Tags:[Breadth First Search, DFS, Graph, Topological Sort]
https://leetcode.com/problems/course-schedule/
v-207.1 Applying Topological Sort technique - Timit Limit excede
START:
public class Solution {

    private int MAX_VERTS = 0;
    private int adjMat[][]; // adjacency matrix
    private int nVerts; // current number of vertices
    private char sortedArray[];

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        this.nVerts = numCourses;
        adjMat = new int[numCourses][numCourses];
        for (int i = 0; i < prerequisites.length; i++) {
            this.addEdge(prerequisites[i][1], prerequisites[i][0]);
        }
        return this.topo();
    }

    public void addEdge(int start, int end) {
        //System.out.println(start);
        //System.out.println(end);
        this.adjMat[start][end] = 1;
    }

    public boolean topo() {
        int orig_nVerts = nVerts; // remember how many verts
        // while vertices remain,
        while (nVerts > 0) {
            // get a vertex with no successors, or -1
            int currentVertex = noSuccessors();
            if (currentVertex == -1) {
                System.out.println("ERROR:Graph has cycle");
                return false;
            }
            deleteVertex(currentVertex); // delete vertex
        }
        return true;
    }
    // returns vert with no successors/childs
    public int noSuccessors() {
        boolean isEdge; // edge from row to column in adjMat
        // for each vertex, check edges
        for (int row = 0; row < nVerts; row++) {
            isEdge = false;
            for (int col = 0; col < nVerts; col++) {
                // if edge to another this vertex has a successor
                if (adjMat[row][col] > 0) {
                    isEdge = true;
                    break;
                }
            } // try another

            // if no edges,
            if (!isEdge) {
                return row; // has no successors
            }
        }
        return -1; // no such vertex
    }

    public void deleteVertex(int delVert) {
            // delete row from adjMat
            for (int row = delVert; row < nVerts - 1; row++) {
                moveRowUp(row, nVerts);
            }
            // delete col from adjMat
            for (int col = delVert; col < nVerts - 1; col++) {
                moveColLeft(col, nVerts - 1);
            }
            nVerts--; // one less vertex
    }
    private void moveRowUp(int row, int length) {
        for (int col = 0; col < length; col++) {
            adjMat[row][col] = adjMat[row + 1][col];
        }
    }

    private void moveColLeft(int col, int length) {
        for (int row = 0; row < length; row++) {
            adjMat[row][col] = adjMat[row][col + 1];
        }
    }
}
:END
207. Course Schedule
Tags:[Breadth First Search, DFS, Graph, Topological Sort]
https://leetcode.com/problems/course-schedule/
v-207.2 Standard: NOT Accepted
START:
package leetcode;

import java.util.Arrays;

class Solution {

    private int adjMat[][]; // adjacency matrix
    private int nVerts; // current number of vertices
    private boolean[] isCompletable;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        this.nVerts = numCourses;
        this.isCompletable = new boolean[numCourses];
        adjMat = new int[numCourses][numCourses];
        for (int i = 0; i < prerequisites.length; i++) {
            this.addEdge(prerequisites[i][0], prerequisites[i][1]);
        }
        return this.isCompletable();
    }

    public void addEdge(int start, int end) {
        this.adjMat[start][end] = 1;
    }

    private boolean isCompletable() {
        boolean isCompletable = true;
        for (int r = 0; r < this.nVerts; r++) {
            for (int c = 0; c < this.nVerts; c++) {//prerequisites
                if (this.adjMat[r][c] == 1 && !this.isCompletableIte(r, c)) {
                    return false;
                }
            }
            this.isCompletable[r] = true;
        }

        return true;
    }

    // stackoverflow
    private boolean isCompletableRec(int currentCourse, int course) {
        boolean isCompletable = true;
        // cycle
        if (currentCourse == course) {
            return false;
        }

        if (this.isCompletable[course]) {
            return true;
        }

        for (int c = 0; c < this.nVerts; c++) {
            if (this.adjMat[course][c] == 1) {
                isCompletable = this.isCompletableRec(currentCourse, c);
                if (!isCompletable) {
                    return false;
                }
                this.isCompletable[c] = true;
            }
        }
        this.isCompletable[course] = true;
        return true;
    }

    private boolean isCompletableIte(int currentCourse, int course) {
        if (this.isCompletable[course]) {
            return true;
        }

        boolean flag = true;
        boolean[] visited = new boolean[this.nVerts];
        int[] courses = new int[this.nVerts];

        courses[0] = course;
        int coursesNum = 1;
        boolean hasPreReq = false;
        while (coursesNum > 0) {
            course = courses[coursesNum - 1];
            // cycle
            if (currentCourse == course) {
                return false;
            }

            for (int c = 0; c < this.nVerts; c++) {
                if (this.adjMat[course][c] == 1 && !visited[c]) {
                    courses[coursesNum++] = c;
                    hasPreReq = true;
                    break;
                    //this.isCompletable[c] = true;
                }
            }

            if (hasPreReq) {
            } else {
                this.isCompletable[course] = true;
                coursesNum--;
            }
        }
        return true;
    }

}

:END

Topics: Data Stream
------------------------
1656. Design an Ordered Stream
Tags:[Array, HashTable, Design, Data Stream]
https://leetcode.com/problems/design-an-ordered-stream/
v-1656.1 Standard
START:
class OrderedStream {
    private int ptr;
    private String[] strArr;

    public OrderedStream(int n) {
        ptr = 1;
        strArr = new String[n + 2]; 
    }

    public List<String> insert(int idKey, String value) {
        this.strArr[idKey] = value;
        return this.getChunkList();
    }

    // get continuation items
    private List<String> getChunkList() {
        List<String> chunks = new ArrayList<>();
        while (this.strArr[this.ptr] != null) {
            chunks.add(this.strArr[this.ptr]);
            this.ptr++;
        }
        return chunks;
    }
}

/**
 * Your OrderedStream object will be instantiated and called as such:
 * OrderedStream obj = new OrderedStream(n);
 * List<String> param_1 = obj.insert(idKey,value);
 */
:END


Topics: String Matching
------------------------
1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence
Tags:[String, String Matching]
https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/
v-1455.1 Naive
START:
class Solution {
    public int isPrefixOfWord(String sentence, String searchWord) {
        int prefixLength = searchWord.length();
        String[] words = sentence.split(" ");
        for (int i = 0; i < words.length; i++) {
            if (words[i].length() >= prefixLength) {
                String subString = words[i].substring(0, prefixLength);
                if (subString.equals(searchWord)) {
                    return i + 1;
                }
            }
        }
        return -1;
    }
}
:END
v-1455.2 Trie


Topics: Enumeration
------------------------
1534. Count Good Triplets
Tags:[Array, Enumeration]
https://leetcode.com/problems/count-good-triplets/
v-1534.1 Brute Force
START:
class Solution {
    public int countGoodTriplets(int[] arr, int a, int b, int c) {
        int counter = 0;

        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                for (int k = j + 1; k < arr.length; k++) {
                    int tripletsFactor1 = Math.abs(arr[i] - arr[j]);
                    int tripletsFactor2 = Math.abs(arr[j] - arr[k]);
                    int tripletsFactor3 = Math.abs(arr[i] - arr[k]);
                    if (tripletsFactor1 <= a && tripletsFactor2 <= b && tripletsFactor3 <= c) {
                        counter++;
                    }
                }
            }
        }
        return counter;
    }
}
:END

Topics: Reservoir Sampling
------------------------
398. Random Pick Index
Tags:[HashTable, Math, Reservoir Sampling, Randomized]
https://leetcode.com/problems/random-pick-index/
v-398.1 Reservoir Sampling
START:
:END
