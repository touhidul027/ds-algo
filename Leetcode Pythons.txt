Topics: Maths
---------------
7. Reverse Integer
https://leetcode.com/problems/reverse-integer/
V7.1
from typing import List
class Solution:
    def reverse(self, x: int) -> int:
        isNegative = False
        if x < 0:
            isNegative = True
            x = -1 * x
        org = str(x)
        indexLen = len(org) - 1
        revChars = []
        i = 0
        while indexLen >= 0:
            revChars.insert(i,org[indexLen])
            i = i + 1
            indexLen = indexLen - 1
        return self.getReversedNumber(revChars,isNegative)

    def getReversedNumber(self, revChars:List, negative:bool) -> int:
        numFlag = 1
        maxNum = ['2', '1', '4', '7', '4', '8', '3', '6', '4', '7']
        if negative:
            numFlag = -1
            maxNum[9] = '8';
        if len(revChars) > len(maxNum):
            return 0
        elif len(revChars) < len(maxNum):
            return numFlag * self.charArrayToInteger(revChars)
        else:
            l = len(maxNum)
            for i in range(l):
                if maxNum[i] == revChars[i]:
                    continue
                elif maxNum[i] > revChars[i]:
                    return numFlag * self.charArrayToInteger(revChars)
                else:
                    return 0
        return numFlag * self.charArrayToInteger(revChars)

    def charArrayToInteger(self, arr:List) -> int:
        str = ''.join(arr)
        number = int(str)
        return number

x = -12345
obj = Solution()
number = obj.reverse(x)
print(number)


Topics: Tree
---------------------
226. Invert Binary Tree
https://leetcode.com/problems/invert-binary-tree/
V226.1
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if root is None:
            return root
        tempNode = root.left
        root.left = root.right
        root.right = tempNode
        root.left = self.invertTree(root.left)
        root.right = self.invertTree(root.right)
        return root

Topics: Greedy
---------------------
455. Assign Cookies
https://leetcode.com/problems/assign-cookies/
V455.1
START:
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort();
        s.sort()
        gLen = len(g)
        sLen = len(s)
        currentCookieIndex = 0
        contentChildNumber = 0
        i = 0
        while i < gLen and currentCookieIndex < sLen:
            if g[i] <= s[currentCookieIndex]:
                contentChildNumber = contentChildNumber + 1
                currentCookieIndex = currentCookieIndex + 1
            else:
                currentCookieIndex = currentCookieIndex + 1
                i = i-1
            i = i + 1
        return contentChildNumber
:END

Topics: HashTable
---------------------
205. Isomorphic Strings
https://leetcode.com/problems/isomorphic-strings/
V205.1
START:
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        sMap = {}
        tMap = {}
        length = len(s)
        for i in range(length):
            sCh = s[i]
            tCh = t[i]
            if sCh in sMap:
                if tCh != sMap[sCh]:
                    return False
            elif tCh in tMap:
                return False
            else:
                sMap[sCh] = tCh
                tMap[tCh] = sCh
        return True
:END


Topics: Binary Search
---------------------
278. First Bad Version
https://leetcode.com/problems/first-bad-version/
V278.1 Time Limit excede
START:
class Solution:
    def firstBadVersion(self, n):
        lastGoodVersion = 0
        lastBadVersion = n
        while (lastBadVersion - lastGoodVersion) != 1:
            n = lastGoodVersion + (lastBadVersion - lastGoodVersion) / 2
            isBad = isBadVersion(n)
            if isBad:
                lastBadVersion = n
            else:
                lastGoodVersion = n
        return lastBadVersion
:END

V278.2 Accepted
START:
class Solution:
# The isBadVersion API is already defined for you.
# @param version, an integer
# @return an integer
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        left = 1
        right = n
        while left < right:
            mid = left + int((right - left) / 2)
            isBad = isBadVersion(mid)
            if isBad:
                right = mid
            else:
                left = mid + 1

        return left
:END

Topics: Breadth-First-Search
----------------------------
993. Cousins in Binary Tree
https://leetcode.com/problems/cousins-in-binary-tree/
V993.1
START:
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from queue import Queue
class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        q = Queue(maxsize = 100)
        q.put(root)
        executeLoop = True
        isCousins = False
        while executeLoop:
            currentLevelNodesNumber = q.qsize()
            if currentLevelNodesNumber == 0:
                break;

            for i in range(currentLevelNodesNumber):
                curNode = q.get();
                tArr = [];

                leftNode = curNode.left;
                if leftNode:
                    q.put(leftNode);
                    tArr.append(leftNode.val)

                rightNode = curNode.right;
                if rightNode:
                    q.put(rightNode);
                    tArr.append(rightNode.val)

                if executeLoop == False and self.isValueExists(tArr, x, y):
                    return True;
                elif self.isValueExists(tArr, x, y):
                    executeLoop = False; # perform search only in this level
        return isCousins

    def isValueExists(self, tArr: List, x: int, y: int) -> bool:
        for num in tArr:
            if num == x or num == y:
                return True;
        return False
V993.2 try recursively
V993.3 try using dfs
:END

Topics: Sort
----------------------------
1528. Shuffle String
https://leetcode.com/problems/shuffle-string/
V1528.1
START:
class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        length = len(indices)
        newS = list(s)
        for i in range(length):
            newS[indices[i]] = s[i]

        return ''.join(newS)

:END
